{"searchDocs":[{"title":"ArgumentContext","type":0,"sectionRef":"#","url":"/api/ArgumentContext","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"ArgumentContext","url":"/api/ArgumentContext#properties","content":" ","version":null,"tagName":"h2"},{"title":"Command​","type":1,"pageTitle":"ArgumentContext","url":"/api/ArgumentContext#Command","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ArgumentContext.Command: CommandContext The command that this argument belongs to.  ","version":null,"tagName":"h3"},{"title":"Type​","type":1,"pageTitle":"ArgumentContext","url":"/api/ArgumentContext#Type","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ArgumentContext.Type: TypeDefinition The type definition for this argument.  ","version":null,"tagName":"h3"},{"title":"Name​","type":1,"pageTitle":"ArgumentContext","url":"/api/ArgumentContext#Name","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ArgumentContext.Name: string The name of this argument, shown on the autocomplete interface.  ","version":null,"tagName":"h3"},{"title":"Object​","type":1,"pageTitle":"ArgumentContext","url":"/api/ArgumentContext#Object","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ArgumentContext.Object: ArgumentDefinition The raw argument definition.  ","version":null,"tagName":"h3"},{"title":"Required​","type":1,"pageTitle":"ArgumentContext","url":"/api/ArgumentContext#Required","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ArgumentContext.Required: boolean Whether or not this argument was required.  ","version":null,"tagName":"h3"},{"title":"Executor​","type":1,"pageTitle":"ArgumentContext","url":"/api/ArgumentContext#Executor","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ArgumentContext.Executor: Player  The player that ran the command that this argument belongs to.  ","version":null,"tagName":"h3"},{"title":"RawValue​","type":1,"pageTitle":"ArgumentContext","url":"/api/ArgumentContext#RawValue","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ArgumentContext.RawValue: string The raw, unparsed value for this argument.  ","version":null,"tagName":"h3"},{"title":"RawSegments​","type":1,"pageTitle":"ArgumentContext","url":"/api/ArgumentContext#RawSegments","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ArgumentContext.RawSegments: {string} An array of strings representing the values in a comma-separated list, if applicable.  ","version":null,"tagName":"h3"},{"title":"Prefix​","type":1,"pageTitle":"ArgumentContext","url":"/api/ArgumentContext#Prefix","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ArgumentContext.Prefix: string The prefix used in this argument (like % in %Team). Empty string if no prefix was used. See Prefixed Union Types for more details. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"ArgumentContext","url":"/api/ArgumentContext#functions","content":" ","version":null,"tagName":"h2"},{"title":"GetTransformedValue​","type":1,"pageTitle":"ArgumentContext","url":"/api/ArgumentContext#GetTransformedValue","content":"&lt;/&gt; ArgumentContext:GetTransformedValue(segment: number) → ...any Returns the transformed value from this argument, see Types.  ","version":null,"tagName":"h3"},{"title":"GetValue​","type":1,"pageTitle":"ArgumentContext","url":"/api/ArgumentContext#GetValue","content":"&lt;/&gt; ArgumentContext:GetValue() → any Returns the parsed (final) value for this argument. ","version":null,"tagName":"h3"},{"title":"CommandContext","type":0,"sectionRef":"#","url":"/api/CommandContext","content":"CommandContext Represents an individual command execution. Beta This page is incomplete. You might want to refer to the current documentation.","keywords":"","version":null},{"title":"Dispatcher","type":0,"sectionRef":"#","url":"/api/Dispatcher","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"Dispatcher","url":"/api/Dispatcher#properties","content":" ","version":null,"tagName":"h2"},{"title":"CmdrX​","type":1,"pageTitle":"Dispatcher","url":"/api/Dispatcher#CmdrX","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Dispatcher.CmdrX: CmdrX | CmdrClient A reference to CmdrX. This may either be the server or client version of CmdrX depending on where the code is running.  ","version":null,"tagName":"h3"},{"title":"Registry​","type":1,"pageTitle":"Dispatcher","url":"/api/Dispatcher#Registry","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Dispatcher.Registry: Registry  ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Dispatcher","url":"/api/Dispatcher#functions","content":" ","version":null,"tagName":"h2"},{"title":"EvaluateAndRun​","type":1,"pageTitle":"Dispatcher","url":"/api/Dispatcher#EvaluateAndRun","content":"&lt;/&gt; Dispatcher:EvaluateAndRun( text: string, executor: Player? , options: { Data: any?, IsHuman: boolean?, }? ) → string-- Command output or error message Runs a command as the given player. Executor is optional when running on the client. If options.Data is given, it will be available on the server with CommandContext.GetData If options.IsHuman is true and this function is called on the client, then the text will be inserted into the window history.  ","version":null,"tagName":"h3"},{"title":"Run​","type":1,"pageTitle":"Dispatcher","url":"/api/Dispatcher#Run","content":"This item only works when running on the client. Client &lt;/&gt; Dispatcher:Run(...: string...) → string Invokes a command programmatically as the local player. Accepts a variable number of arguments, which are all joined with spaces before being run; the command should be the first argument. This function will raise an error if any validations occur, since it's only for hard-coded (or generated) commands.  ","version":null,"tagName":"h3"},{"title":"GetHistory​","type":1,"pageTitle":"Dispatcher","url":"/api/Dispatcher#GetHistory","content":"This item only works when running on the client. Client &lt;/&gt; Dispatcher:GetHistory() → {string} Returns an array of the user's command history. Most recent commands are inserted at the end of the array. ","version":null,"tagName":"h3"},{"title":"Best practice","type":0,"sectionRef":"#","url":"/docs/advanced/bestpractice","content":"Best practice Work in progress We're sorry but this article has yet to be written.","keywords":"","version":"Next"},{"title":"Customising the interface","type":0,"sectionRef":"#","url":"/docs/advanced/customisinginterface","content":"","keywords":"","version":"Next"},{"title":"Duplicate ScreenGui​","type":1,"pageTitle":"Customising the interface","url":"/docs/advanced/customisinginterface#duplicate-screengui","content":" You should note that if you have CharacterAutoLoads set to false and you load CmdrXClient before StarterGui loads (which is on the first character spawn) then you will end up with two CmdrX ScreenGuis. This normally is not an issue, but if you're also customising the CmdrX interface by hooking into PlayerGui.CmdrX then this could be problematic.  You can mitigate this issue by refraining from requiring CmdrXClient until after PlayerGui has loaded, but this will create a delay in users being able to access CmdrX until after their character has spawned for the first time.  Alternatively, you could:  Delete CmdrX from StarterGui on the server, after you've required the CmdrX serverOn the client, load your modified copy of CmdrX ScreenGui into PlayerGui (you can skip this step if you only want the default ScreenGui)And then, once you've inserted the gui, require CmdrXClient ","version":"Next","tagName":"h2"},{"title":"Report security vulnerability","type":0,"sectionRef":"#","url":"/docs/community/securityreport","content":"","keywords":"","version":"Next"},{"title":"A quick note for our users​","type":1,"pageTitle":"Report security vulnerability","url":"/docs/community/securityreport#a-quick-note-for-our-users","content":" It's important that you keep your libraries up to date. We do not monitor, accept reports pertaining to, provide support for, or patch bugs on old versions of CmdrX.  If you're experiencing issues, our first recommendation will always be to update CmdrX; this applies even if the update is major (breaking).  Making sure you're always running the newest version of CmdrX will give you access to the latest features and bug fixes, and also keep your game safe from any vulnerabilities we find or are alerted to. ","version":"Next","tagName":"h2"},{"title":"Cookbook","type":0,"sectionRef":"#","url":"/docs/community/cookbook","content":"Cookbook Work in progress We're sorry but this article has yet to be written.","keywords":"","version":"Next"},{"title":"Contributing","type":0,"sectionRef":"#","url":"/docs/contribute/","content":"Contributing Work in progress We're sorry but this article has yet to be written.","keywords":"","version":"Next"},{"title":"Hooks","type":0,"sectionRef":"#","url":"/docs/hooks","content":"","keywords":"","version":"Next"},{"title":"BeforeRun​","type":1,"pageTitle":"Hooks","url":"/docs/hooks#beforerun","content":" The callback is passed the CommandContext for the relevant command. The hooks are the last thing to run before the command itself, so all properties are available.  This hook can be used to interrupt command execution (useful for permissions) by returning a string. The returned string will replace the command output on the executing user's screen. If the callback returns nothing (nil or no return), then the command will run normally.  Security Warning Commands will be blocked from running in a live game unless you register at least one BeforeRun hook.  As a quick way to register hooks on both the server and the client, you can make a folder for your hooks, with module scripts in them which return a function. Similar to Types, if you call CmdrX.Registry:RegisterHooksIn(yourFolderHere) from the server, CmdrX will load all ModuleScripts in the folder on the server and the client, so you only need to write your code once.  A ModuleScript inside your hooks folder. return function (registry) registry:RegisterHook(&quot;BeforeRun&quot;, function(context) if context.Group == &quot;DefaultAdmin&quot; and context.Executor.UserId ~= game.CreatorId then return &quot;You don't have permission to run this command&quot; end end) end   ","version":"Next","tagName":"h2"},{"title":"AfterRun​","type":1,"pageTitle":"Hooks","url":"/docs/hooks#afterrun","content":" The AfterRun hook runs directly after a command is run. The callback is also passed a CommandContext, but the Response property is now available, which is the response from the command implementation (what would normally be displayed after running the command).  If this callback returns a string, then it will replace the normal response on the user's screen. If the callback returns nothing (nil or no return), then the response will be shown normally.  This hook is most useful for logging. Since we don't want to add this hook on the client in this example, we can just require the server version of CmdrX and add this hook directly right here (as opposed to what we did in the BeforeRun example, which adds the hook to the client as well):  CmdrX.Registry:RegisterHook(&quot;AfterRun&quot;, function(context) print(context.Response) -- see the actual response from the command execution return &quot;Returning a string from this hook replaces the response message with this text&quot; end)   ","version":"Next","tagName":"h2"},{"title":"Execution order​","type":1,"pageTitle":"Hooks","url":"/docs/hooks#execution-order","content":" BeforeRun hook on client.Data function on client.ClientRun function on client.BeforeRun hook on server. *Server command implementation returned from Server module. *AfterRun hook on server. *AfterRun hook on client.  * Only runs if ClientRun isn't present or ClientRun returns nil.  You should be aware that an exploiter can, in theory, manipulate or bypass any client parts of execution. This isn't an issue though as exploiters can already do anything that's possible for a client component to do, but you should keep it in mind when designing your systems. ","version":"Next","tagName":"h2"},{"title":"Installation","type":0,"sectionRef":"#","url":"/docs/installation","content":"","keywords":"","version":"Next"},{"title":"Model file (recommended)​","type":1,"pageTitle":"Installation","url":"/docs/installation#model-file-recommended","content":" You can visit the latest release page. At the bottom of the page, you'll find an &quot;Assets&quot; section, then download CmdrX.rbxm  If you're using Roblox Studio:  You can either: drag or drop the CmdrX.rbxm file into the viewport (central window)select the Model tab, then under the Advanced section click Model. Then, navigate to the CmdrX.rbxm file and click Open Make sure you move the CmdrX ModuleScript to wherever you want it (as above, we recommend you keep it on the server)Proceed to Setup  If you're using Rojo, you can either add the CmdrX.rbxm file to your project file (usually called default.project.json), or put the CmdrX.rbxm file into a directory that you've got set up to sync already. Rojo's documentation can help you with this.  ","version":"Next","tagName":"h2"},{"title":"Wally (recommended) (requires Rojo)​","type":1,"pageTitle":"Installation","url":"/docs/installation#wally-recommended-requires-rojo","content":" CmdrX is published on the wally registry as BiraruX/CmdrX; you should be cautious about the potential for malware and only use the official package.  You can easily add CmdrX to your project's wally.toml file. If you're experiencing difficulties, Wally's documentation can help.  We recommend adding CmdrX to the 'server realm', you can do this by putting it under the server-dependencies section. This'll put it in a ServerPackages folder (which you'll then need to sync into your game using Rojo).  [server-dependencies] CmdrX = &quot;birarux/cmdrx@^1.13.0&quot;   Make sure you check what the latest version is. The caret (^) will tell Wally to automatically upgrade to the newest compatible version if available, which we recommend doing.  ","version":"Next","tagName":"h2"},{"title":"Submodule (advanced) (requires Rojo)​","type":1,"pageTitle":"Installation","url":"/docs/installation#submodule-advanced-requires-rojo","content":" If your project is using Rojo and Git, then you can use Git Submodules to include CmdrX into your project, and then sync it into your game using Rojo.  This will include a lot of unnecessary files into your project though, like the website and documentation, so you should make sure you only pull or sync the CmdrX directory (which is the library source code).  We recommend 'pinning' to the latest version's tag, rather than using the master branch. This is because pre-release versions may have unexpected bugs, glitches or changes, and we may not be able to offer you support unless you're using the latest released version.  ","version":"Next","tagName":"h2"},{"title":"Manual (not recommended) (requires Rojo)​","type":1,"pageTitle":"Installation","url":"/docs/installation#manual-not-recommended-requires-rojo","content":" Using git clone or GitHub's Download button, you can download a copy of the source code and then take the CmdrX directory and sync this into your place.  We recommend downloading the latest version rather than using the master branch. This is because pre-release versions may have unexpected bugs, glitches or changes, and we may not be able to offer you support unless you're using the latest released version.  ","version":"Next","tagName":"h2"},{"title":"Roblox models (not supported)​","type":1,"pageTitle":"Installation","url":"/docs/installation#roblox-models-not-supported","content":" CmdrX is not published to the Roblox creator marketplace. Owing to the prevalence of malware, you should not use any publish of CmdrX on the Roblox library, and instead use one of the above installation methods.  If you're experiencing difficulties and need help, then you can find advice on getting help in the Introduction page. ","version":"Next","tagName":"h2"},{"title":"Commands","type":0,"sectionRef":"#","url":"/docs/commands","content":"","keywords":"","version":"Next"},{"title":"Command data​","type":1,"pageTitle":"Commands","url":"/docs/commands#command-data","content":" If you need to gather some data from the client before the command runs, you can create a Data function in your command. This function will run on the client, and whatever is returned from it will be available with context:GetData() in the command implementation.  As an example, you might want to know the local player's current mouse world position in a server command. This can be achieved by returning LocalPlayer:GetMouse().Hit.Position from the Data function, then using context:GetData() to get the Vector3.  context:GetData() will work on both client and server commands.  ","version":"Next","tagName":"h2"},{"title":"Client commands​","type":1,"pageTitle":"Commands","url":"/docs/commands#client-commands","content":" It is possible to have commands that run on the client exclusively or both.  If you want your command to run on the client, you can add a ClientRun function to the command definition itself. It works exactly like the function that you would return from the Server module.  If using ClientRun, having a Server module associated with this command is optional. If your ClientRun function returns a string, the command will run entirely on the client and won't touch the server at all (which means server-only hooks won't run). If this function doesn't return anything, it will then execute the associated Server module implementation on the server (including any server-sided hooks).  caution If the ClientRun function is present and there isn't a Server module for this command then you must return a string from the ClientRun function.  ","version":"Next","tagName":"h2"},{"title":"Execution order​","type":1,"pageTitle":"Commands","url":"/docs/commands#execution-order","content":" Including Hooks, the full execution order is:  BeforeRun hook on client.Data function on client.ClientRun function on client.BeforeRun hook on server. *Server command implementation returned from Server module. *AfterRun hook on server. *AfterRun hook on client.  * Only runs if ClientRun isn't present or ClientRun returns nil.  You should be aware that an exploiter can, in theory, manipulate or bypass any client parts of execution. This isn't an issue though as exploiters can already do anything that's possible for a client component to do, but you should keep it in mind when designing your systems.  ","version":"Next","tagName":"h2"},{"title":"Default commands​","type":1,"pageTitle":"Commands","url":"/docs/commands#default-commands","content":" Possibly outdated We've not reviewed this section for a while, it's possible that this information may be out of date.  If you run CmdrX.Registry:RegisterDefaultCommands(), these commands will be available with the following Groups:  Group: DefaultAdmin: announce (m), bring, kick, teleport (tp), kill, respawn, to  Group: DefaultDebug: blink (b), thru (t), position, version, fetch, get-player-place-instance, uptime  Group: DefaultUtil: alias, bind, unbind, run (&gt;), runif, echo, hover, replace (//, gsub), history, me, var, var=, json-array-encode, json-array-decode, resolve, len, pick, rand, edit, goto-place  Group: Help: help  ","version":"Next","tagName":"h2"},{"title":"Registering a subset of the default commands​","type":1,"pageTitle":"Commands","url":"/docs/commands#registering-a-subset-of-the-default-commands","content":" If you only want some, but not all, of the default commands, you can restrict the commands that you register in two ways.  Pass an array of groups to the RegisterDefaultCommands function: CmdrX.Registry:RegisterDefaultCommands({&quot;Help&quot;, &quot;DefaultUtil&quot;})Pass a filter function that accepts a CommandDefinition and either returns true or false:  CmdrX.Registry:RegisterDefaultCommands(function(cmd) return #cmd.Name &lt; 6 -- This is absurd... but possible! end)   More practically, you could use this to create an allow list of default commands you want in your game, and ones you don't.  ","version":"Next","tagName":"h3"},{"title":"Argument value operators​","type":1,"pageTitle":"Commands","url":"/docs/commands#argument-value-operators","content":" Instead of typing out an entire argument, you can insert the following operators as a shorthand.  Operator\tMeaning\tListable types only.\tDefault value for the type\tNo ?\tA random value from all possible values\tNo *\tA list of all possible values\tYes **\tAll possible values minus the default value.\tYes ?N\tN random values picked from all possible values\tYes  &quot;All possible values&quot; is determined automatically by using the values that are displayed in the autocomplete menu when you haven't typed anything for that argument yet.  If you want CmdrX to interpret the operator as literal text, you can escape these operators by inserting a \\ before them. For example: \\* will be interpreted as a literal *.  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Commands","url":"/docs/commands#example","content":" For the players type, this is the meaning of the operators:  Operator\tMeaning.\t&quot;me&quot;, or the player who is running the command. ?\tA random single player. *\tAll players. **\t&quot;others&quot;, or all players who aren't the player running the command. ?N\tN random players.  So: kill * kills all players, while kill ** kills all players but you.  ","version":"Next","tagName":"h3"},{"title":"resolve command​","type":1,"pageTitle":"Commands","url":"/docs/commands#resolve-command","content":" The resolve command can be used to retrieve the true value of these operators as a list. It takes a type and an operator as arguments, and returns the list as a string.  Examples:  Input\tOutputresolve players .\tPlayer1 resolve players *\tPlayer1,Player2,Player3,Player4 resolve players **\tPlayer2,Player3,Player4 resolve players ?\tPlayer3  ","version":"Next","tagName":"h3"},{"title":"Prefixed union types​","type":1,"pageTitle":"Commands","url":"/docs/commands#prefixed-union-types","content":" An argument can be allowed to accept a different type when starting with a specific prefix. The most common example of this is with the players type, which when prefixed with % allows the user to select players based on team, rather than name.  These can be defined on a per-argument basis, so that your commands can accept many types of arguments in a single slot. Under the Args section of command definition, each argument has a Type key. For arguments that accept only a single type, it would look like Type = &quot;string&quot;. If we also wanted to accept a number when the user prefixes the argument with #, we could change it to: Type = &quot;string # number&quot;. Then, if the user provided #33 for this argument, your function would be delivered the number value 33 in that position.  This is infinitely expandable, and you can include as many prefixed union types as you wish: Type = &quot;string # number @ player % team&quot;, etc. Remember that there must be a space between the symbol and the type.  Some default types automatically have a prefixed union type applied to them, because they would both resolve to the same type in the end. For example, whenever you define an argument of type players, under the hood this is perceived as players % teamPlayers. (teamPlayers is a type that matches based on team name, but resolves to an array of Players: the same thing that the normal players type would resolve with.)  Here is a list of automatic prefixed union types:  Type\tUnionplayers\tplayers % teamPlayers playerId\tplayerId # integer playerIds\tplayerIds # integers brickColor\tbrickColor % teamColor brickColors\tbrickColors % teamColors color3\tcolor3 # hexColor3 ! brickColor3 color3s\tcolor3s # hexColor3s ! brickColor3s  ","version":"Next","tagName":"h2"},{"title":"Dynamic arguments and inline types​","type":1,"pageTitle":"Commands","url":"/docs/commands#dynamic-arguments-and-inline-types","content":" Dynamic types are included within a command definition's Args array, they are functions which take in the command context and then return an ArgumentDefinition. Despite being called inline types, they are not types themselves. This is as opposed to static arguments, which are ArgumentDefinitions rather than functions.  Inline types allow developers to save time adding bespoke types for individual commands, or types which need to vary depending on the command context. For example, you could have an allowlist command which takes an enum of add or remove as its first argument, the second argument then could be a playerId (for add) or a custom allowlistPlayer type (for remove) depending on the first argument.  Inline types can be and usually are paired with dynamic types. Inline types are not registered (so their names don't need to be unique) and take advantage of the fact that the Type key in an argument definition can also be a TypeDefinition itself. This is most commonly used with enum types:  allowlist.lua return { Name = &quot;allowlist&quot;, Aliases = {}, Description = &quot;Add or remove a player from the allow list.&quot;, Group = &quot;Admin&quot;, Args = { -- This is an example of a dynamic inline type function(context) return { Type = context.CmdrX.Util.MakeEnumType(&quot;option&quot;, {&quot;add&quot;, &quot;remove&quot;}), Name = &quot;Action&quot;, Description = &quot;Add or remove&quot;, } end, -- This is an example of a dynamic argument function(context) local action = context:GetArgument(1):GetValue() return { Type = if action == &quot;add&quot; then `playerId` else `allowlistPlayer`, Name = &quot;Player&quot;, Description = `The player to {action} from the allow list.`, } end, }, }  ","version":"Next","tagName":"h2"},{"title":"CmdrX","type":0,"sectionRef":"#","url":"/api/CmdrX","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"CmdrX","url":"/api/CmdrX#properties","content":" ","version":null,"tagName":"h2"},{"title":"Registry​","type":1,"pageTitle":"CmdrX","url":"/api/CmdrX#Registry","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; CmdrX.Registry: Registry Refers to the current command Registry.  ","version":null,"tagName":"h3"},{"title":"Dispatcher​","type":1,"pageTitle":"CmdrX","url":"/api/CmdrX#Dispatcher","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; CmdrX.Dispatcher: Dispatcher Refers to the current command Dispatcher.  ","version":null,"tagName":"h3"},{"title":"Util​","type":1,"pageTitle":"CmdrX","url":"/api/CmdrX#Util","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; CmdrX.Util: Util Refers to a table containing many useful utility functions. ","version":null,"tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/intro","content":"","keywords":"","version":"Next"},{"title":"What is CmdrX and who is it for?​","type":1,"pageTitle":"Introduction","url":"/docs/intro#what-is-cmdrx-and-who-is-it-for","content":" CmdrX is a console built for the Roblox platform. It's designed to make it easy for developers to write commands and easy for users to run those commands.  While originally made to help developers with debugging, CmdrX has been popularised as a general console and command system due to its powerful features and extensible nature. Of course, this doesn't mean that you have to use it for debugging or administration; CmdrX can be used in whatever way works for you.  ","version":"Next","tagName":"h2"},{"title":"Why should I use it?​","type":1,"pageTitle":"Introduction","url":"/docs/intro#why-should-i-use-it","content":" CmdrX is exceptionally user friendly thanks to type-safety and intelligent, context-aware auto-complete. This makes a user made aware of typos and mistakes before they even hit enter. Plus, a developer's command implementations doesn't have to check or transform types, you get exactly what you ask for.  Unlike other &quot;admin commands&quot; systems on Roblox, CmdrX quietly integrates with your game rather than getting in the way. This makes it super easy to write your own commands or types which 'plug into' your existing code. Plus, CmdrX is incredibly snappy and will do as much work as possible on the client; providing users, especially those with limited connections, quick feedback.  CmdrX provides a number of helpful commands and a range of powerful types out of the box, but of course you don't have to use them. We're also working on creating a Cookbook which'll showcase even more helpful commands and cool things you can do with CmdrX.  CmdrX also provides meta-commands, empowering users to:  create aliases and/or chain commands togetherbind commands to inputs (like key presses)run commands when you join the game (which, in turn, can do the above!)  CmdrX has been around for over five years and while it's been continuously improved since, it's stood the test of time and is trusted in games with billions of visits earning millions of dollars worth of revenue. For many developers, CmdrX is their go-to when they need a console system, saving them the potentially hundreds of hours of time it would take to develop their own.  ","version":"Next","tagName":"h2"},{"title":"Why shouldn't I use it?​","type":1,"pageTitle":"Introduction","url":"/docs/intro#why-shouldnt-i-use-it","content":" While we think CmdrX is amazing, it may not be right for you if:  You have limited Luau knowledge.  While CmdrX isn't super complex, it may be difficult for beginners and those with limited programming experience.  You'll need to write your own command implementations and permissions yourself; take a look at the How do I get help with CmdrX? section below for more details. Similarly, any features which CmdrX doesn't provide (like bespoke types or logging) you'll also need to write yourself.  You want a large set of pre-made (&quot;plug and play&quot;) commands.  While CmdrX has a set of built-in commands, these are fairly limited. There are plenty of open source &quot;admin commands&quot; systems which, while we can't comment on their quality, do provide a large number of diverse commands coupled with easy set-up.  You may find our Cookbook helpful but it's still fairly limited and you'll need to make the bulk of commands yourself.  Mobile support is mission-critical.  CmdrX's mobile support isn't perfect and is lacking in some areas. Also, you'll need to add some way for mobile and other non-keyboard users to be able to open the console.  First and foremost, CmdrX is a keyboard experience and it has been designed with this in mind. Although, if you think there's any areas that could be improved feel free to open an Issue ticket.  ","version":"Next","tagName":"h2"},{"title":"How do I get started?​","type":1,"pageTitle":"Introduction","url":"/docs/intro#how-do-i-get-started","content":" Do not modify the source code Please do not modify the source code of CmdrX for your game. Instead, use its API to customise the behaviour you want. Modifying the source code makes it much harder for you to receive future updates. There shouldn't be any reason why you need to modify the source code of CmdrX (unless you're adding a new feature or fixing a bug). If there's something you think we're missing, please open an issue.  Take a look at the Installation guide, you can then continue through our documentation from there.  You can also read through the API reference. While we recommend reading the API reference to get a full understanding of CmdrX, it's not required.  We recommend against following any tutorials, particularly on YouTube or the DevForum, to set up CmdrX. These tend to be incorrect or outdated. Take a look at the How do I get help with CmdrX? section below for more details on how to get support and what resources are available.  ","version":"Next","tagName":"h2"},{"title":"How do I get help with CmdrX?​","type":1,"pageTitle":"Introduction","url":"/docs/intro#how-do-i-get-help-with-cmdrx","content":" Luau knowledge — please read! If you don't know how to program with Luau then we recommend you don't use CmdrX. CmdrX is targeted towards those with experience in the Luau language and you will run into bigger problems down the road if you don't know what you're doing. We unfortunately can't 'hand hold' you through things. Setup is a huge, crucial step to determine if you should be using CmdrX or not. It may be a bit frustrating now, but later on if something breaks the frustration will exponentially increase. This is the reason why we tell those who need to touch up on their Luau or programming skills to do so beforehand. Our support channels exist to provide help with CmdrX-specific things, like our API. We cannot answer general Luau questions or help you with a specific command implementation (e.g. &quot;how do I make a fly command?&quot;), although you may find our Cookbook helpful.  There are plenty of resources available to help you with CmdrX, such as this website and our Discord server, but we've been made aware of a number of DevForum guides and YouTube videos which provide incorrect or outdated instructions.  We recommend you stick to our official resources, especially if you're new to CmdrX. If you decide to use unofficial resources, then the level of support we can provide (for instance in our Discord server) is limited.  The CmdrX Discord server has a dedicated CmdrX help channel, which is where we recommend you go to get any support you need. ","version":"Next","tagName":"h2"},{"title":"Meta-commands","type":0,"sectionRef":"#","url":"/docs/metacommands","content":"","keywords":"","version":"Next"},{"title":"Embedded commands​","type":1,"pageTitle":"Meta-commands","url":"/docs/metacommands#embedded-commands","content":" Sub-commands may be embedded inside command strings, in the format ${command arg1 arg2 arg3}. These sub-commands are evaluated just before the command string is run, and are run every time the command string runs. They evaluate to whatever the command returns as output.  Embedded commands are nestable: run echo ${run echo ${echo hello}!} (displays hello!). We use run here instead of just running echo directly, because embedded commands are only evaluated in the preprocess step of commands that use command strings (which is only run, alias, and bind).  By default, if the evaluated command output has a space in it, the return value will be encapsulated in quote marks so that the entire value is perceived as one argument to CmdrX. In cases where it's desirable for CmdrX to parse each word as a separate argument, you can use use a literal syntax: run teleport ${{&quot;echo first second&quot;}​} (in this example, &quot;first&quot; and &quot;second&quot; would then become the first and second arguments to the teleport command, instead of the first argument being &quot;first second&quot;)  ","version":"Next","tagName":"h2"},{"title":"Run​","type":1,"pageTitle":"Meta-commands","url":"/docs/metacommands#run","content":" Run is the simplest of the bunch, and does right what it says on the tin. It runs whatever text you give it immediately as a command. This is useful, because it evaluates embedded commands within the command string before running.  run ${{&quot;echo kill me&quot;}}   Commands can contain more than one distinct command, delimited by &amp;&amp;. This can be escaped by adding an additional ampersand, for example: &amp;&amp;&amp;. You can escape an additional level by adding more. &amp;&amp;&amp;&amp; is a two level deep escape.  When using &amp;&amp;, you can access the previous command's output by using the || slot operator. For example run echo evaera &amp;&amp; kill || would cause evaera to die.  The run command has a single-character alias, &gt;, which can also be used to invoke it.  ","version":"Next","tagName":"h2"},{"title":"Bind​","type":1,"pageTitle":"Meta-commands","url":"/docs/metacommands#bind","content":" Bind is a command that allows you to run a certain command string every time some event happens. The default bind type is by user input (mouse or keyboard input), but you can also bind to other events.  This is very powerful: you could define a command, like cast_ability, which casts a certain move in your game. Then, you could have a keybindings menu that allows the user to rebind keys, and whenever they do, it runs CmdrXClient:Run(&quot;bind&quot;, keyCode.Name, &quot;cast_ability&quot;, abilityId) in the background. By separating the user input from our hypothetical ability code, our code is made more robust as we can now trigger abilities from a number of possible events, in addition to the bound key.  If you prefix the first argument with @, you can instead select a player to bind to, which will run this command string every time that player chats. You can get the chat text by using $1 in your command string.  In the future, you will be able to bind to network events as described in the previous section by prefixing the first argument with !.  The unbind command can be used to unbind anything that bind can bind.  ","version":"Next","tagName":"h2"},{"title":"Alias​","type":1,"pageTitle":"Meta-commands","url":"/docs/metacommands#alias","content":" The alias command lets you create a new, single command out of a command string. Alias commands can contain more than one distinct command, delimited by &amp;&amp;. You can also accept arguments from the command with $1 through $5.  alias farewell announce Farewell, $1! &amp;&amp; kill $1   Then, if we run farewell evaera, it would make an announcement saying Farewell, evaera! and then kill the player called evaera.  As another example, you could create a command that killed anyone your mouse was currently hovering over like so:  alias pointer_of_death kill ${hover}   ","version":"Next","tagName":"h2"},{"title":"Types and Descriptions​","type":1,"pageTitle":"Meta-commands","url":"/docs/metacommands#types-and-descriptions","content":" You can optionally provide types, names, and descriptions to your alias arguments, like so: $1{type|Name|Description here}. For example:  alias goodbye kill $1{player|Player|The player you want to kill.}   Name and Description are optional. These are all okay:  alias goodbye kill $1{player}alias goodbye kill $1{player|Player}alias goodbye kill $1{player|Player|The player you want to kill.}  Additionally, you can supply a description for the command itself:  alias &quot;goodbye|Kills a player.&quot; kill $1{player|Player|The player you want to kill.}   The double quotes here are used to 'escape' the space, meaning it'll get parsed as part of the first argument. This is common in consoles (shells) outside of Roblox. ","version":"Next","tagName":"h3"},{"title":"Network event handlers","type":0,"sectionRef":"#","url":"/docs/networkeventhandlers","content":"Network event handlers Some commands that run on the server might need to also do something on the client, or on every client. Network event handlers are callback functions that you can set to run when a server command sends a message back to the client. Only one handler can be set to a certain event at a time, so it's possible to change the handler for a specific event without needing to re-implement the entire command yourself. For example, consider the default announce command, which creates a message on every player's screen. By default, this creates a system chat message with the given text, because CmdrX has a default event handler for the &quot;Message&quot; event, which the announce command broadcasts. If you wanted to display announcements some other way, you could just override the default event handler: CmdrXClient:HandleEvent(&quot;Message&quot;, function (text, player) print(&quot;Announcement from&quot;, player.Name, text) end) You can send events from your own commands on the server (or to the local player if in a client-only command) by using context:SendEvent(player, ...) and context:BroadcastEvent(...). The built-in context:Reply(text) method actually uses SendEvent under the hood, whose default handler on the client (AddLine) is set to just add a new line to the console window with the given text.","keywords":"","version":"Next"},{"title":"Set-up","type":0,"sectionRef":"#","url":"/docs/setup","content":"","keywords":"","version":"Next"},{"title":"Modifying the source code​","type":1,"pageTitle":"Set-up","url":"/docs/setup#modifying-the-source-code","content":" Do not modify the source code Please do not modify the source code of CmdrX for your game. Instead, use its API to customise the behaviour you want. Modifying the source code makes it much harder for you to receive future updates. There shouldn't be any reason why you need to modify the source code of CmdrX (unless you're adding a new feature or fixing a bug). If there's something you think we're missing, please open an issue.  Modifying the source code also includes putting your commands within CmdrX's BuiltInCommands folder; don't do it. You should never touch the CmdrX library or any of its components outside of code.  ","version":"Next","tagName":"h2"},{"title":"Server setup​","type":1,"pageTitle":"Set-up","url":"/docs/setup#server-setup","content":" You should create a folder to keep your commands inside and then register them on the server. You only need to register commands, types and hooks on the server: CmdrX will automatically handle replication for you. There is no need to modify the actual CmdrX library itself.  -- This is a script you would create in ServerScriptService, for example local ServerScriptService = game:GetService(&quot;ServerScriptService&quot;) local CmdrX = require(path.to.CmdrX) -- e.g. ServerScriptService.Libs.CmdrX CmdrX.Registry:RegisterDefaultCommands() -- Optional: This loads the default set of commands that CmdrX comes with. -- CmdrX.Registry:RegisterCommandsIn(ServerScriptService.CmdrXCommands) -- Optional: Register commands from your own folder. -- You can also register types or hooks here: read on or check the API reference!   The CmdrX object is the main server singleton. The Registry is used on both the client and server, and it keeps track of all the commands, types and hooks that CmdrX knows about.  CmdrX will automatically create and insert into StarterGui its console interface (called Window). If you'd like to (optionally) customise the look of the Window, we have a guide on this in our Advanced section.  CmdrX will also insert into ReplicatedStorage the CmdrXClient module. On top of being the client entry point (read on below!), this module also houses stuff for internal use, like replication (any commands, types and hooks the client needs to know about) and networking.  You're not done yet! Client setup is also required, you need to register CmdrX on the server and client for it to load. Keep going! ↓  ","version":"Next","tagName":"h2"},{"title":"Client setup​","type":1,"pageTitle":"Set-up","url":"/docs/setup#client-setup","content":" From the client, you'll need to require the CmdrXClient module.  CmdrX will place CmdrXClient into ReplicatedStorage automatically, no action is required from you. This module includes things used by CmdrX internally, but also provides you - the developer - with methods to customise and tweak CmdrX.  -- This is a local/client script you would create in StarterPlayerScripts, for example local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local CmdrX = require(ReplicatedStorage:WaitForChild(&quot;CmdrXClient&quot;)) -- Optional. Configurable, and you can choose multiple keys CmdrX:SetActivationKeys({ Enum.KeyCode.F2 }) -- You can call any extra methods here, like SetPlaceName, or access the registry to register a hook on the client only (if you want to!)   Activation keys are used to show or hide CmdrX. By default, this is just F2 but you can have as many or as few keys as you'd like (even none).  ","version":"Next","tagName":"h2"},{"title":"Next steps​","type":1,"pageTitle":"Set-up","url":"/docs/setup#next-steps","content":" By now, CmdrX is up and running, and will work fine in studio. However, you'll probably want to write your own commands and to run any commands in a live server, you must create a BeforeRun hook.  If you ever need help, you can check the support page. ","version":"Next","tagName":"h2"},{"title":"Updating","type":0,"sectionRef":"#","url":"/docs/updating","content":"","keywords":"","version":"Next"},{"title":"Model File (Preferred Method)​","type":1,"pageTitle":"Updating","url":"/docs/updating#model-file-preferred-method","content":" Navigate to the latest release page.Download the most recent CmdrX.rbxm file from the &quot;Assets&quot; section.Open Roblox Studio.Remove the outdated CmdrX ModuleScript from your game.Import the updated CmdrX.rbxm file by either: Dragging and dropping it into the viewport, orAccessing the Model tab → Advanced section → Selecting Model, then locating and opening the downloaded file. Relocate the CmdrX ModuleScript to ServerScriptService or ServerStorage for optimal security and performance.Conduct thorough testing to confirm seamless integration.  ","version":"Next","tagName":"h2"},{"title":"Wally Package Manager (Recommended for Rojo Users)​","type":1,"pageTitle":"Updating","url":"/docs/updating#wally-package-manager-recommended-for-rojo-users","content":" Open your project's wally.toml configuration file.Update the CmdrX dependency version as follows: [server-dependencies] CmdrX = &quot;birarux/cmdrx@^latest-version&quot; Replace latest-version with the latest release version, available here.Execute the following command: wally install Synchronize your updated dependencies using Rojo.Run tests to ensure compatibility.  ","version":"Next","tagName":"h2"},{"title":"Git Submodule (Advanced Users, Requires Rojo)​","type":1,"pageTitle":"Updating","url":"/docs/updating#git-submodule-advanced-users-requires-rojo","content":" Open a terminal in your project's root directory.Execute the following command to fetch the latest updates: git submodule update --remote Synchronize project files using Rojo, if required.Validate functionality by running comprehensive tests.  ","version":"Next","tagName":"h2"},{"title":"Manual Update (Not Recommended)​","type":1,"pageTitle":"Updating","url":"/docs/updating#manual-update-not-recommended","content":" Download the latest CmdrX source code from the latest release.Extract and replace your existing CmdrX directory with the newly downloaded version.Use Rojo to sync the updated folder with your project.Perform rigorous testing to detect and resolve potential issues.  ","version":"Next","tagName":"h2"},{"title":"Post-Update​","type":1,"pageTitle":"Updating","url":"/docs/updating#post-update","content":" Avoid modifying CmdrX's core source code, as it breaks future updates and may introduce unexpected behavior.Review the changelog for any critical updates, breaking changes, or new features.  For troubleshooting or further assistance, visit the BiraruX Discord server.  Work in progress We're sorry but this article has yet to be written. ","version":"Next","tagName":"h2"},{"title":"Util","type":0,"sectionRef":"#","url":"/api/Util","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Util","url":"/api/Util#functions","content":" ","version":null,"tagName":"h2"},{"title":"MakeDictionary​","type":1,"pageTitle":"Util","url":"/api/Util#MakeDictionary","content":"&lt;/&gt; Util.MakeDictionary(array: {any}) → {[any]: true} Takes an array and flips its values into dictionary keys with value of true.  ","version":null,"tagName":"h3"},{"title":"DictionaryKeys​","type":1,"pageTitle":"Util","url":"/api/Util#DictionaryKeys","content":"&lt;/&gt; Util.DictionaryKeys(dict: {[any]: any}) → {any} Takes a dictionary and returns its keys.  ","version":null,"tagName":"h3"},{"title":"MakeFuzzyFinder​","type":1,"pageTitle":"Util","url":"/api/Util#MakeFuzzyFinder","content":"&lt;/&gt; Util.MakeFuzzyFinder(setOrContainer: any) → ( string, boolean?, boolean? ) → string Returns a function that is a fuzzy finder for the specified set or container. Can pass an array of strings, array of instances, array of EnumItems, array of dictionaries with a Name key or an instance (in which case its children will be used). Exact matches will be inserted in the front of the resulting array.  ","version":null,"tagName":"h3"},{"title":"GetNames​","type":1,"pageTitle":"Util","url":"/api/Util#GetNames","content":"&lt;/&gt; Util.GetNames(instances: any) → {string} Takes an array of instances (or anything with a Name property) and maps them into an array of their names. If no Name property is present, then tostring will be called instead.  ","version":null,"tagName":"h3"},{"title":"SplitStringSimple​","type":1,"pageTitle":"Util","url":"/api/Util#SplitStringSimple","content":"&lt;/&gt; Util.SplitStringSimple( input: string, sep: string? ) → {string} Splits a string using a simple separator (no quote parsing)  ","version":null,"tagName":"h3"},{"title":"ParseEscapeSequences​","type":1,"pageTitle":"Util","url":"/api/Util#ParseEscapeSequences","content":"&lt;/&gt; Util.ParseEscapeSequences(text: string) → string Parses escape sequences into their fully qualified characters  ","version":null,"tagName":"h3"},{"title":"EncodeEscapedOperator​","type":1,"pageTitle":"Util","url":"/api/Util#EncodeEscapedOperator","content":"&lt;/&gt; Util.EncodeEscapedOperator( text: string, op: string ) → string No description.  ","version":null,"tagName":"h3"},{"title":"EncodeEscapedOperators​","type":1,"pageTitle":"Util","url":"/api/Util#EncodeEscapedOperators","content":"&lt;/&gt; Util.EncodeEscapedOperators(text: string) → string No description.  ","version":null,"tagName":"h3"},{"title":"SplitString​","type":1,"pageTitle":"Util","url":"/api/Util#SplitString","content":"&lt;/&gt; Util.SplitString( text: string, max: number ) → {string} Splits a string by space but taking into account quoted sequences which will be treated as a single argument.  ","version":null,"tagName":"h3"},{"title":"MashExcessArguments​","type":1,"pageTitle":"Util","url":"/api/Util#MashExcessArguments","content":"&lt;/&gt; Util.MashExcessArguments( arguments: {string}, max: number ) → {string} Takes an array of arguments and a max value. Any indicies past the max value will be appended to the last valid argument.  ","version":null,"tagName":"h3"},{"title":"TrimString​","type":1,"pageTitle":"Util","url":"/api/Util#TrimString","content":"&lt;/&gt; Util.TrimString(str: string) → string Trims whitespace from both sides of a string.  ","version":null,"tagName":"h3"},{"title":"GetTextSize​","type":1,"pageTitle":"Util","url":"/api/Util#GetTextSize","content":"&lt;/&gt; Util.GetTextSize( text: string, label: TextLabel , size: Vector2? ) → Vector2  Returns the text bounds size based on given text, label (from which properties will be pulled), and optional Vector2 container size.  ","version":null,"tagName":"h3"},{"title":"MakeEnumType​","type":1,"pageTitle":"Util","url":"/api/Util#MakeEnumType","content":"&lt;/&gt; Util.MakeEnumType( name: string, values: any ) → TypeDefinition Makes an Enum type.  ","version":null,"tagName":"h3"},{"title":"ParsePrefixedUnionType​","type":1,"pageTitle":"Util","url":"/api/Util#ParsePrefixedUnionType","content":"&lt;/&gt; Util.ParsePrefixedUnionType( typeValue: string, rawValue: string ) → ( string?, string?, string? ) Parses a prefixed union type argument (such as %Team)  ","version":null,"tagName":"h3"},{"title":"MakeListableType​","type":1,"pageTitle":"Util","url":"/api/Util#MakeListableType","content":"&lt;/&gt; Util.MakeListableType( type: TypeDefinition, override: table ) → TypeDefinition Creates a listable type from a singular type  ","version":null,"tagName":"h3"},{"title":"RunCommandString​","type":1,"pageTitle":"Util","url":"/api/Util#RunCommandString","content":"&lt;/&gt; Util.RunCommandString( dispatcher: Dispatcher, commandString: string ) → string?-- output from Dispatcher:EvaluateAndRun as a string Creates a listable type from a singular type  ","version":null,"tagName":"h3"},{"title":"RunEmbeddedCommands​","type":1,"pageTitle":"Util","url":"/api/Util#RunEmbeddedCommands","content":"&lt;/&gt; Util.RunEmbeddedCommands( dispatcher: Dispatcher, str: string ) → string Runs embedded commands and replaces them  ","version":null,"tagName":"h3"},{"title":"SubstituteArgs​","type":1,"pageTitle":"Util","url":"/api/Util#SubstituteArgs","content":"&lt;/&gt; Util.SubstituteArgs( str: string, replace: string ) → string Replaces arguments in the format $1, $2, $something with whatever the given function returns for it.  ","version":null,"tagName":"h3"},{"title":"MakeAliasCommand​","type":1,"pageTitle":"Util","url":"/api/Util#MakeAliasCommand","content":"&lt;/&gt; Util.MakeAliasCommand( name: string, commandString: string ) → CommandDefinition Creates an alias command, should only be used on the client.  ","version":null,"tagName":"h3"},{"title":"MakeSequenceType​","type":1,"pageTitle":"Util","url":"/api/Util#MakeSequenceType","content":"&lt;/&gt; Util.MakeSequenceType(options: { Parse: function?, Constructor: function?, TransformEach: function?, ValidateEach: function?, Prefixes: {string}?, Length: number? }) → ArgumentDefinition Makes a type that contains a sequence, e.g. Vector3 or Color3 For options, one of Constructor or Parse is required  ","version":null,"tagName":"h3"},{"title":"SplitPrioritizedDelimeter​","type":1,"pageTitle":"Util","url":"/api/Util#SplitPrioritizedDelimeter","content":"&lt;/&gt; Util.SplitPrioritizedDelimeter( text: string, delimiters: {string} ) → {string}? Splits a string by a single delimeter chosen from the given set. The first matching delimeter from the set becomes the split character. ","version":null,"tagName":"h3"},{"title":"Types","type":0,"sectionRef":"#","url":"/docs/types","content":"","keywords":"","version":"Next"},{"title":"Default value​","type":1,"pageTitle":"Types","url":"/docs/types#default-value","content":" You can specify a &quot;default value&quot; for your type by adding a Default function to it. For example, the default value for the players type is the name of the player who ran the command. The Default function should always return a string, as this is inserted before parsing.  For any argument whose type has a default value, you can simply input . and the default value will automatically be used in its place. E.g. kill .  ","version":"Next","tagName":"h2"},{"title":"Enum types​","type":1,"pageTitle":"Types","url":"/docs/types#enum-types","content":" Because Enum types are so common, there is a special function that easily lets you create an Enum type. When a command has an argument of this type, it'll always be a string matching exactly one of the strings in the array you define (see below).  return function (registry) registry:RegisterType(&quot;place&quot;, registry.CmdrX.Util.MakeEnumType(&quot;Place&quot;, {&quot;World 1&quot;, &quot;World 2&quot;, &quot;World 3&quot;, &quot;Final World&quot;})) end  ","version":"Next","tagName":"h2"},{"title":"CmdrXClient","type":0,"sectionRef":"#","url":"/api/CmdrXClient","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"CmdrXClient","url":"/api/CmdrXClient#properties","content":" ","version":null,"tagName":"h2"},{"title":"Registry​","type":1,"pageTitle":"CmdrXClient","url":"/api/CmdrXClient#Registry","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; CmdrXClient.Registry: Registry Refers to the current command Registry.  ","version":null,"tagName":"h3"},{"title":"Dispatcher​","type":1,"pageTitle":"CmdrXClient","url":"/api/CmdrXClient#Dispatcher","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; CmdrXClient.Dispatcher: Dispatcher Refers to the current command Dispatcher.  ","version":null,"tagName":"h3"},{"title":"Util​","type":1,"pageTitle":"CmdrXClient","url":"/api/CmdrXClient#Util","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; CmdrXClient.Util: Util Refers to a table containing many useful utility functions.  ","version":null,"tagName":"h3"},{"title":"Enabled​","type":1,"pageTitle":"CmdrXClient","url":"/api/CmdrXClient#Enabled","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; CmdrXClient.Enabled: boolean Whether or not CmdrX is enabled (will show via the defined activation keys). Use CmdrXClient:SetEnabled to change.  ","version":null,"tagName":"h3"},{"title":"PlaceName​","type":1,"pageTitle":"CmdrXClient","url":"/api/CmdrXClient#PlaceName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; CmdrXClient.PlaceName: string The current place name, displayed on the interface. Use CmdrXClient:SetPlaceName to change.  ","version":null,"tagName":"h3"},{"title":"ActivationKeys​","type":1,"pageTitle":"CmdrXClient","url":"/api/CmdrXClient#ActivationKeys","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; CmdrXClient.ActivationKeys: {[Enum.KeyCode]=true} The list of key codes that will show or hide CmdrX. Use CmdrXClient:SetActivationKeys to change. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"CmdrXClient","url":"/api/CmdrXClient#functions","content":" ","version":null,"tagName":"h2"},{"title":"SetActivationKeys​","type":1,"pageTitle":"CmdrXClient","url":"/api/CmdrXClient#SetActivationKeys","content":"&lt;/&gt; CmdrXClient:SetActivationKeys(keys: {Enum.KeyCode}) → () Sets the key codes that will used to show or hide CmdrX.  ","version":null,"tagName":"h3"},{"title":"SetPlaceName​","type":1,"pageTitle":"CmdrXClient","url":"/api/CmdrXClient#SetPlaceName","content":"&lt;/&gt; CmdrXClient:SetPlaceName(name: string) → () Sets the place name label on the interface. This is useful for a quick way to tell what game you're playing in a universe game.  ","version":null,"tagName":"h3"},{"title":"SetEnabled​","type":1,"pageTitle":"CmdrXClient","url":"/api/CmdrXClient#SetEnabled","content":"&lt;/&gt; CmdrXClient:SetEnabled(enabled: boolean) → () Sets whether or not CmdrX can be shown via the defined activation keys. Useful for when you want users to opt-in to show the console, for instance in a settings menu.  ","version":null,"tagName":"h3"},{"title":"SetActivationUnlocksMouse​","type":1,"pageTitle":"CmdrXClient","url":"/api/CmdrXClient#SetActivationUnlocksMouse","content":"&lt;/&gt; CmdrXClient:SetActivationUnlocksMouse(enabled: boolean) → () Sets if activation will free the mouse.  ","version":null,"tagName":"h3"},{"title":"Show​","type":1,"pageTitle":"CmdrXClient","url":"/api/CmdrXClient#Show","content":"&lt;/&gt; CmdrXClient:Show() → () Shows the CmdrX window. Does nothing if CmdrX isn't enabled.  ","version":null,"tagName":"h3"},{"title":"Hide​","type":1,"pageTitle":"CmdrXClient","url":"/api/CmdrXClient#Hide","content":"&lt;/&gt; CmdrXClient:Hide() → () Hides the CmdrX window.  ","version":null,"tagName":"h3"},{"title":"Toggle​","type":1,"pageTitle":"CmdrXClient","url":"/api/CmdrXClient#Toggle","content":"&lt;/&gt; CmdrXClient:Toggle() → () Toggles the CmdrX window. Does nothing if CmdrX isn't enabled.  ","version":null,"tagName":"h3"},{"title":"SetMashToEnable​","type":1,"pageTitle":"CmdrXClient","url":"/api/CmdrXClient#SetMashToEnable","content":"&lt;/&gt; CmdrXClient:SetMashToEnable(enabled: boolean) → () Enables the &quot;Mash to open&quot; feature. This feature, when enabled, requires the activation key to be pressed 5 times within a second to enable CmdrX. This may be helpful to guard against mispresses from opening the window, for example.  ","version":null,"tagName":"h3"},{"title":"SetHideOnLostFocus​","type":1,"pageTitle":"CmdrXClient","url":"/api/CmdrXClient#SetHideOnLostFocus","content":"&lt;/&gt; CmdrXClient:SetHideOnLostFocus(enabled: boolean) → () Sets the hide on 'lost focus' feature. This feature, which is enabled by default, will cause CmdrX to hide when the user clicks off the window.  ","version":null,"tagName":"h3"},{"title":"HandleEvent​","type":1,"pageTitle":"CmdrXClient","url":"/api/CmdrXClient#HandleEvent","content":"&lt;/&gt; CmdrXClient:HandleEvent( name: string, callback: (...any) → () ) → () Sets the network event handler for a certain event type. ","version":null,"tagName":"h3"},{"title":"Registry","type":0,"sectionRef":"#","url":"/api/Registry","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Registry","url":"/api/Registry#types","content":" ","version":null,"tagName":"h2"},{"title":"HookType​","type":1,"pageTitle":"Registry","url":"/api/Registry#HookType","content":"&lt;/&gt; type HookType = &quot;BeforeRun&quot; | &quot;AfterRun&quot;   ","version":null,"tagName":"h3"},{"title":"ArgumentDefinition​","type":1,"pageTitle":"Registry","url":"/api/Registry#ArgumentDefinition","content":"&lt;/&gt; interface ArgumentDefinition { Type: string | TypeDefinition-- The argument type (case sensitive), or an inline TypeDefinition object. Name: string-- The argument name, this is displayed to the user as they type. Description: string?-- A description of what the argument is, this is also displayed to the user. Optional: boolean?-- If this is set to true, then the user can run the command without filling out the value. In which case, the argument will be sent to implementations as nil. Default: any?-- If present, the argument will be automatically made optional, so if the user doesn't supply a value, implementations will receive whatever the value of Default is. } The table definition, usually contained in a CommandDefinition, which 'defines' the argument.  ","version":null,"tagName":"h3"},{"title":"CommandDefinition​","type":1,"pageTitle":"Registry","url":"/api/Registry#CommandDefinition","content":"&lt;/&gt; interface CommandDefinition { Name: string-- The name of the command Aliases: {string}?-- Aliases which aren't part of auto-complete, but if matched will run this command just the same. For example, m might be an alias of announce. Description: string?-- A description of the command, displayed to the user in the help command and auto-complete menu. Group: string?-- This property is intended to be used in hooks, so that you can categorise commands and decide if you want a specific user to be able to run them or not. But the help command will use them as headings. Args: {ArgumentDefinition | (CommandContext) → (ArgumentDefinition)}-- Arguments for the command; this is technically optional but if you have no args, set it to {} or you may experience some interface weirdness. Data: ( CommandContext, ... ) → any-- If your command needs to gather some extra data from the client that's only available on the client, then you can define this function. It should accept the command context and tuple of transformed arguments, and return a single value which will be available in the command with CommandContext:GetData. ClientRun: ( CommandContext, ... ) → string?-- If you want your command to run on the client, you can add this function to the command definition itself. It works exactly like the function that you would return from the Server module. If this function returns a string, the command will run entirely on the client and won't touch the server (which means server-only hooks won't run). If this function doesn't return anything, it will fall back to executing the Server module on the server. Run: ( CommandContext, ... ) → string?-- An older version of ClientRun. There are very few scenarios where this is preferred to ClientRun (so, in other words, don't use it!). These days, Run is only used for some dark magic involving server-sided command objects. }   ","version":null,"tagName":"h3"},{"title":"TypeDefinition​","type":1,"pageTitle":"Registry","url":"/api/Registry#TypeDefinition","content":"&lt;/&gt; interface TypeDefinition { Prefixes: string?-- String containing prefixed union types for this type. This property should omit the inital type, so the string should begin with a prefix character, e.g. Prefixes = &quot;# integer ! boolean&quot; DisplayName: string?-- Overrides the user-facing name of this type in the autocomplete menu. Otherwise, the registered name of the type will be used. Default: ((Player ) → string)?-- Should return the &quot;default&quot; value for this type as a string. For example, the default value of the player type is the name of the player who ran the command. Listable: boolean?-- If true, this will tell CmdrX that comma-separated lists are allowed for this type. CmdrX will automatically split the list and parse each segment through your Transform, Validate, Autocomplete and Parse functions individually, so you don't have to change the logic of your type at all. The only limitation is that your Parse function must return a table, the tables from each individual segment's Parse functions will be merged into one table at the end of the parsing step. The uniqueness of values is ensured upon merging, so even if the user lists the same value several times, it will only appear once in the final table. Transform: ( string, Player ) → T?-- Transform is an optional function that is passed two values: the raw text, and the player running the command. Then, whatever values this function returns will be passed to all other functions in the type (Validate, Autocomplete and Parse). Validate: (T) → ( boolean, string? )-- The Validate function is passed whatever is returned from the Transform function (or the raw value if there is no Transform function). If the value is valid for the type, it should return true. If the value is invalid, it should return two values: false and a string containing an error message. If this function is omitted, anything will be considered valid. ValidateOnce: (T) → ( boolean, string? )-- This function works exactly the same as the normal Validate function, except it only runs once (after the user presses Enter). This should only be used if the validation process is relatively expensive or needs to yield. For example, the playerId type uses this because it needs to call GetUserIdFromNameAsync in order to validate. For the vast majority of types, you should just use Validate instead. Autocomplete: (T) → ( {string}, {IsPartial: boolean?}? )?-- Should only be present for types that are possible to be auto-completed. It should return an array of strings that will be displayed in the auto-complete menu. It can also return a second value, containing a dictionary of options (currently, IsPartial: if true then pressing Tab to auto-complete won't continue onwards to the next argument.) Parse: (T) → any-- Parse is the only required function in a type definition. It is the final step before the value is considered finalised. This function should return the actual parsed value that will be sent to implementations. } The table definition, contained in an ArgumentDefinition or registered, which 'defines' the argument. ","version":null,"tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"Registry","url":"/api/Registry#properties","content":" ","version":null,"tagName":"h2"},{"title":"CmdrX​","type":1,"pageTitle":"Registry","url":"/api/Registry#CmdrX","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Registry.CmdrX: CmdrX | CmdrXClient A reference to CmdrX. This may either be the server or client version of CmdrX depending on where the code is running. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Registry","url":"/api/Registry#functions","content":" ","version":null,"tagName":"h2"},{"title":"RegisterType​","type":1,"pageTitle":"Registry","url":"/api/Registry#RegisterType","content":"&lt;/&gt; Registry:RegisterType( name: string,-- The name of the type, this must be unique, alphanumeric, and start with a lower-case letter or digit. typeObject: TypeDefinition ) → () Registers a type on the current realm (server/client), this function should be called from within the type definition ModuleScript.  ","version":null,"tagName":"h3"},{"title":"RegisterTypePrefix​","type":1,"pageTitle":"Registry","url":"/api/Registry#RegisterTypePrefix","content":"&lt;/&gt; Registry:RegisterTypePrefix( name: string,-- The name of the type. union: string-- The string should omit the initial type name, so this string should begin with a prefix character, e.g. # integer ! boolean ) → () Registers a Prefixed Union Type string on the current realm (server/client), this function should be called from within the type definition ModuleScript. If there are already type prefixes for the given type name, they will be concatenated. This allows you to add prefixes to default types, like players.  ","version":null,"tagName":"h3"},{"title":"RegisterTypeAlias​","type":1,"pageTitle":"Registry","url":"/api/Registry#RegisterTypeAlias","content":"&lt;/&gt; Registry:RegisterTypeAlias( name: string,-- The name of the type, this must be unique, alphanumeric, and start with a lower-case letter or digit. alias: string-- The string should include the initial type name, e.g. string # integer ! boolean ) → () Allows you to register a name which will be expanded into a longer type which can be used as a command argument type. For example, if you register the alias stringOrNumber it could be interpreted as string # number when used.  ","version":null,"tagName":"h3"},{"title":"RegisterTypesIn​","type":1,"pageTitle":"Registry","url":"/api/Registry#RegisterTypesIn","content":"This item only works when running on the server. Server &lt;/&gt; Registry:RegisterTypesIn(container: Instance ) → () Registers all types from within a container on both the server and client.  ","version":null,"tagName":"h3"},{"title":"RegisterHooksIn​","type":1,"pageTitle":"Registry","url":"/api/Registry#RegisterHooksIn","content":"This item only works when running on the server. Server &lt;/&gt; Registry:RegisterHooksIn(container: Instance ) → () Registers all hooks from within a container on both the server and client. If you want to add a hook only on the server or client – e.g. for logging – then you should use the Register.RegisterHook method instead.  ","version":null,"tagName":"h3"},{"title":"RegisterCommand​","type":1,"pageTitle":"Registry","url":"/api/Registry#RegisterCommand","content":"This item only works when running on the server. Server &lt;/&gt; Registry:RegisterCommand( commandScript: ModuleScript , commandServerScript: ModuleScript? , filter: (CommandDefinition → boolean)?-- If present, will be passed a command definition which will then only be registered if the function returns true. ) → () Registers a command definition and its server equivalent. Handles replicating the definition to the client.  ","version":null,"tagName":"h3"},{"title":"RegisterCommandsIn​","type":1,"pageTitle":"Registry","url":"/api/Registry#RegisterCommandsIn","content":"This item only works when running on the server. Server &lt;/&gt; Registry:RegisterCommandsIn( container: Instance , filter: ((CommandDefinition) → boolean)?-- If present, will be passed a command definition which will then only be registered if the function returns true. ) → () Registers all commands from within a container on both the server and client. Module scripts which include Server in their name will not be sent to the client.  ","version":null,"tagName":"h3"},{"title":"RegisterDefaultCommands​","type":1,"pageTitle":"Registry","url":"/api/Registry#RegisterDefaultCommands","content":"This item only works when running on the server. Server &lt;/&gt; Registry:RegisterDefaultCommands(arrayOrFunc: {string} | (CommandDefinition) → boolean | nil) → () Registers the default commands on both the server and client. The optional arrayOrFunc parameter can be provided with: an array of strings — this will limit registration to only commands which have their Group property set to this a function which takes in a CommandDefinition and returns a boolean — only if true is returned will the command be registered  ","version":null,"tagName":"h3"},{"title":"GetCommand​","type":1,"pageTitle":"Registry","url":"/api/Registry#GetCommand","content":"&lt;/&gt; Registry:GetCommand(name: string) → CommandDefinition? Returns the CommandDefinition from the given name, or nil if no command is found. Command aliases are also accepted.  ","version":null,"tagName":"h3"},{"title":"GetCommands​","type":1,"pageTitle":"Registry","url":"/api/Registry#GetCommands","content":"&lt;/&gt; Registry:GetCommands() → {CommandDefinition} Returns an array of all registers commands, not including aliases.  ","version":null,"tagName":"h3"},{"title":"GetCommandNames​","type":1,"pageTitle":"Registry","url":"/api/Registry#GetCommandNames","content":"&lt;/&gt; Registry:GetCommandNames() → {string} Returns an array of containing the names of all registered commands, not including aliases.  ","version":null,"tagName":"h3"},{"title":"GetTypeNames​","type":1,"pageTitle":"Registry","url":"/api/Registry#GetTypeNames","content":"&lt;/&gt; Registry:GetTypeNames() → {string} Returns an array of containing the names of all registered types, not including aliases.  ","version":null,"tagName":"h3"},{"title":"GetType​","type":1,"pageTitle":"Registry","url":"/api/Registry#GetType","content":"&lt;/&gt; Registry:GetType(name: string) → TypeDefinition? Returns the type definition from the given name, or nil if no argument is found.  ","version":null,"tagName":"h3"},{"title":"GetTypeName​","type":1,"pageTitle":"Registry","url":"/api/Registry#GetTypeName","content":"&lt;/&gt; Registry:GetTypeName(name: string) → TypeDefinition | string Returns a type name taking aliases into account. If there is no alias, the name parameter is simply returned as a pass through.  ","version":null,"tagName":"h3"},{"title":"RegisterHook​","type":1,"pageTitle":"Registry","url":"/api/Registry#RegisterHook","content":"&lt;/&gt; Registry:RegisterHook( hookName: HookType, callback: (CommandContext) → string?,-- returns nil for ok, string (errorText) for cancellation priority: number-- If unspecified, the priority will default to 0. ) → () Registers a hook on the current realm (server/client). This should probably be ran on the server or in a hook module script, but can also work on the client. Hooks run in order of priority from lowest (running first) to highest.  ","version":null,"tagName":"h3"},{"title":"GetStore​","type":1,"pageTitle":"Registry","url":"/api/Registry#GetStore","content":"&lt;/&gt; Registry:GetStore(name: string) → table Returns a table saved with the given name. Always returns the same table on subsequent calls. Useful for commands that require persistent state, like bind or ban. This is the same as CommandContext.GetStore.  ","version":null,"tagName":"h3"},{"title":"GetCommandsAsStrings​","type":1,"pageTitle":"Registry","url":"/api/Registry#GetCommandsAsStrings","content":"deprecated in v1.8.0 &lt;/&gt; This was deprecated in v1.8.0 This method was renamed to GetCommandNames in v1.8.0. The old name exists for backwards compatibility and should not be used for new work. Registry:GetCommandsAsStrings() → ()   ","version":null,"tagName":"h3"},{"title":"AddHook​","type":1,"pageTitle":"Registry","url":"/api/Registry#AddHook","content":"deprecated in v1.1.2 &lt;/&gt; This was deprecated in v1.1.2 This method was renamed to RegisterHook in v1.1.2. The old name exists for backwards compatibility and should not be used for new work. Registry:AddHook( hookName: HookType, callback: (CommandContext) → string?,-- returns nil for ok, string (errorText) for cancellation priority: number-- If unspecified, the priority will default to 0. ) → ()  ","version":null,"tagName":"h3"}],"options":{"id":"default"}}