"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[960],{28822:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"hooks","title":"Hooks","description":"Hooks are callback functions that you can register which hook into the command execution process. Hooks are extremely useful: they can be used for implementing a permission system, logging commands, or overriding command output.","source":"@site/docs/11-hooks.md","sourceDirName":".","slug":"/hooks","permalink":"/docs/hooks","draft":false,"unlisted":false,"editUrl":"https://github.com/BiraruX/CmdrX/edit/main/docs/11-hooks.md","tags":[],"version":"current","sidebarPosition":11,"frontMatter":{},"sidebar":"defaultSidebar","previous":{"title":"Commands","permalink":"/docs/commands"},"next":{"title":"Types","permalink":"/docs/types"}}');var t=o(74848),s=o(28453);const i={},l="Hooks",a={},c=[{value:"BeforeRun",id:"beforerun",level:2},{value:"AfterRun",id:"afterrun",level:2},{value:"Execution order",id:"execution-order",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"hooks",children:"Hooks"})}),"\n",(0,t.jsxs)(n.p,{children:["Hooks are callback functions that you can register which ",(0,t.jsx)(n.em,{children:"hook"})," into the command execution process. Hooks are extremely useful: they can be used for implementing a permission system, logging commands, or overriding command output."]}),"\n",(0,t.jsx)(n.p,{children:"Hooks can be registered on either or both the server and the client. Server commands will run server and client hooks, and client commands will run only client hooks. Depending on your application, you may need to register hooks on one or both. For example, logging may only need to be registered on the server, but permissions might need to be registered on the client in addition to the server."}),"\n",(0,t.jsx)(n.p,{children:"There can be many hooks of each type, and they are all run until one returns a string, which will replace the command response in the console."}),"\n",(0,t.jsx)(n.h2,{id:"beforerun",children:"BeforeRun"}),"\n",(0,t.jsxs)(n.p,{children:["The callback is passed the ",(0,t.jsx)(n.a,{href:"/api/CommandContext",children:"CommandContext"})," for the relevant command. The hooks are the last thing to run before the command itself, so all properties are available."]}),"\n",(0,t.jsxs)(n.p,{children:["This hook can be used to interrupt command execution (useful for permissions) by returning a string. The returned string will replace the command output on the executing user's screen. If the callback returns nothing (",(0,t.jsx)(n.code,{children:"nil"})," or no return), then the command will run normally."]}),"\n",(0,t.jsx)(n.admonition,{title:"Security Warning",type:"caution",children:(0,t.jsx)(n.p,{children:"Commands will be blocked from running in a live game unless you register at least one BeforeRun hook."})}),"\n",(0,t.jsxs)(n.p,{children:["As a quick way to register hooks on both the server and the client, you can make a folder for your hooks, with module scripts in them which return a function. Similar to Types, if you call ",(0,t.jsx)(n.a,{href:"/api/Registry#RegisterHooksIn",children:(0,t.jsx)(n.code,{children:"CmdrX.Registry:RegisterHooksIn(yourFolderHere)"})})," from the server, CmdrX will load all ModuleScripts in the folder on the server and the client, so you only need to write your code once."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",metastring:'title="A ModuleScript inside your hooks folder."',children:'return function (registry)\r\n\tregistry:RegisterHook("BeforeRun", function(context)\r\n\t\tif context.Group == "DefaultAdmin" and context.Executor.UserId ~= game.CreatorId then\r\n\t\t\treturn "You don\'t have permission to run this command"\r\n\t\tend\r\n\tend)\r\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"afterrun",children:"AfterRun"}),"\n",(0,t.jsxs)(n.p,{children:["The AfterRun hook runs directly after a command is run. The callback is also passed a ",(0,t.jsx)(n.a,{href:"/api/CommandContext",children:"CommandContext"}),", but the ",(0,t.jsx)(n.code,{children:"Response"})," property is now available, which is the response from the command implementation (what would normally be displayed after running the command)."]}),"\n",(0,t.jsxs)(n.p,{children:["If this callback returns a string, then it will replace the normal response on the user's screen. If the callback returns nothing (",(0,t.jsx)(n.code,{children:"nil"})," or no return), then the response will be shown normally."]}),"\n",(0,t.jsx)(n.p,{children:"This hook is most useful for logging. Since we don't want to add this hook on the client in this example, we can just require the server version of CmdrX and add this hook directly right here (as opposed to what we did in the BeforeRun example, which adds the hook to the client as well):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'CmdrX.Registry:RegisterHook("AfterRun", function(context)\r\n  print(context.Response) -- see the actual response from the command execution\r\n  return "Returning a string from this hook replaces the response message with this text"\r\nend)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"execution-order",children:"Execution order"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"BeforeRun"})," hook on client."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Data"})," function on client."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ClientRun"})," function on client."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"BeforeRun"})," hook on server. *"]}),"\n",(0,t.jsx)(n.li,{children:"Server command implementation returned from Server module. *"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AfterRun"})," hook on server. *"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AfterRun"})," hook on client."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["* Only runs if ",(0,t.jsx)(n.code,{children:"ClientRun"})," isn't present or ",(0,t.jsx)(n.code,{children:"ClientRun"})," returns ",(0,t.jsx)(n.code,{children:"nil"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"You should be aware that an exploiter can, in theory, manipulate or bypass any client parts of execution. This isn't an issue though as exploiters can already do anything that's possible for a client component to do, but you should keep it in mind when designing your systems."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,o)=>{o.d(n,{R:()=>i,x:()=>l});var r=o(96540);const t={},s=r.createContext(t);function i(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);